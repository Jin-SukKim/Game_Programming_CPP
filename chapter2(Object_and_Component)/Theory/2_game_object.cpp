/*  
    Chapter 2 asset sprite images are created by Jacob Zinman_Jeanes, CC BY License

    Chapter2  코드는 하이브리드 Actor/Component 모델, SpriteComponent,
    AnimSpriteCompoentn, 시간차 스크롤의 구현을 포함한다.
    
    (Chapter 2에선 입력장치는 신경쓰지 않고 있다.)
    매우 간단한 게임은 하나의 Game 클래스로 구현할 수 있지만
    게임 크기가 커지면 좋지 않다.

    게임 객체(Game object)는 게임 세계에서 자신을
    갱신하거나 그리거나 또는 둘 다 수행하는 모든 오브젝트이다

    게임 객체 표현 방법

    1. 객체 계층 구조
    2. 합성(composition)
    etc 여러 구현 방법에 상관없이 게임 객체를 추적, 갱신하는 방법이 필요하다.

    일반적으로 update 동안 갱신되며 rendering 에서 그려진다.

    정적 객체(static object) : 개발자가 오브젝트를 그리기는 하지만 갱신하지 않는 게임 객체
        - 빌딩, 벽 등 주로 배경
    
    카메라 : 자신을 갱신하지만 화면에 그려지지 않는 게임 객체
    트리거(Trigger) : 다른 물체와의 교차로 인해 발생하는 이벤트의 원인
        - 트리거 오브젝트로 오브젝트와 오브젝트의 부딪힘을 감지하는 것

    게임 객체 모델(game object model)은 수없이 많고, 게임 객체 표현 법은 여러가지가 존재한다.

    클래스 계층 구조로서의 게임 객체
    모든 게임 객체가 하나의 기본 클래스를 상속하기에 모놀리식 클래스(monolithic class)라고도 불린다

    기본 클래스를 선언하고 기본 클래스를 상속한 다양한 캐릭터는 각각의 서브클래스를 가진다.
    (ex: Actor_ex class 와 PacMan_ex 클래스)
    
    단점은 모든 게임 객체가 기본 게임 객체의 모든 속성과 기능을 가져야 한다는 것이다.
    (눈에 보이지 않는 객체에 기본 클래스의 Draw를 호축하는 것은 시간 낭비이다.)
    
    대안책으로 Actor와 이동이 피룡한 서브클래스 사이에 
    새로운 movinfactor를 계층 구조에 추가할 수 있지만 계층 구조가 복잡해진다.

    그리고 다중 상속을 하게 되는 경우 다이아몬드 상속(diamond inheritance)라
    불리는 구조로 문제를 일으킬 수도 있따.

    컴포넌트로 구성된 게임 객체

    계층 구조 대신 많이 사용되는 컴포넌트(Component) 기반 게임 객체 모델이다.(유니티에서 사용중)

    게임 객체 클래스는 존재하지만, 서브클래스는 없다.
    대신 게임 객체 클래스는 필요에 따라 기능을 구현한 컴포넌트 객체의
    컬렉션(Collection)을 갖고 있다.

    ex) pinky 클래스가 계층 구조에서 ghost의 서브 클래스이며 Actor의 서브클래스라면,
        컴포넌트 기반 모델에선 4개의 컴포넌트를 소유한 GameObject 인스턴스다.
        PinkyComponent, CollisionComponent, TransformComponen, DrawComponent.

    컴포넌트(Component)는 각각에 필요한 특정한 속성과 기능이 있다.
    (DrawCoponent : 그리기, TransformComponent : 위치와 변환 등)

    컴포넌트 객체 모델은 컴포넌트를 기반으로 하는 클래스 계층도를 가지는 것이다.
    일반적으로 깊이가 매우 얕다.

    GameObject는 오직 컴포넌트를 추가, 제거하는 함수만 갖고 있다.
    즉, 해당 컴포넌트를 추적하는 시스템 구축이 필요하다.

    장점은 특정 기능이 필요한 게임 객체에만 해당 기능을 구현한
    컴포넌트를 추가하면 된다는 것이다.

    단점은 게임 객체 컴포넌트들 간의 의존성이 명확하지 않다는 점이다.
    (ex: DrawComponent가 그리기위해 TranformComponent를 알아야 어디에 그릴지 알 수 있다.)
    즉, 성능 병목 현상을 일으킬수도 있다.

    컴포넌트와 계층 구조로 구성된 게임 객체

    모놀리식 계층 구조와 컴포넌트 객체 모델을 섞은 하이브리드 형태도 존재한다.
    (언리얼 엔진 4의 게임 객체 모델)
    (ex: actor class와 component class)

    actor 클래스는 추가 액터 생성을 포함한 몇 가지 이유덕에 Game 클래스에 접근해야 한다.
    한 가지 방법은 게임 객체를 싱글턴(Singleton)으로 만드는 것이다.

    Singleton은 단일하고 전역적으로 접근 가능한 클래스 인스턴스다.
    싱글턴 패턴은 클래스에 여러 인스턴스가 필요하다고 판단되는 상황이 오면 문제가 발생한다.

    지금 예제는 의존성 주입(dependency injection)이란 접근법을 사용한다.
    이 접근법은 Actor 생성자가 Game 클래스의 포인터를 받는다.
    Actor는 다른 Actor를 생성하거나 Game 함수에 접근하기 위해 이 포인터를 사용하면 된다.

    이 하이브리드 접근법의 계층 구조 깊이는 순수 컴포넌트 기반 모델보다는 더 크지만,
    모놀리식 객체 모델의 깊은 클래스 계층 구조를 피하는데 효과적이다.

    또한 Actor는 변환 데이터와 같은 중요 속성을 갖고 있기에
    컴포넌트 간 통신 오버헤드(Overhead)를 완전히 제거하지 못하지만, 어느정도 피한다.


    다른 접근법

    일부 객체 모델은 여러 기능을 선언하려고 인터페이스 클래스를 사용하며,
    각 게임 객체는 이 인터페이스를 구현한다.

    게임 객체로부터 컴포넌트가 완전히 제거된, 컴포넌트 모델을 더 확장한 방법도 있다.
    숫자 식별자로 컴포넌트를 추적하는 컴포넌트 데이터베이스를 사용한다.

    객체를 속성으로 정의한 접근법도 있다.
    객체에 체력 속성을 정의하면 체력에 대한 컨트롤을 한다.

    각 접근법엔 장단점이 있다.


    Chapter2의 프로젝트에서 Actor는 자신의 생성자나 소멸자에서 Actor 자신을
    게임에 자동으로 추가하고 제거한다.
*/  