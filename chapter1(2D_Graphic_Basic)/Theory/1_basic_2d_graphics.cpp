/*
    오늘날의 대부분의 디스플레이는 래스터 그래픽스(Raster graphics)를 사용한다.
    디스플레이가 2차원 격자 형태의 그림 요소(픽셀)을 갖고 있음을 뜻한다.

    해상도(resolution)은 픽셀 격자의 너비와 높이를 나타낸다

    색상은 빨강, 녹색, 파랑(RGB) 3가지 색깔을 함계 섞어 나타낸다.
    RGB 색깔의 다양한 세기가 결합해 색상의 범위(gamut)가 결정된다.
    RGB외의 색상 포맷도 있다.

    투명도 지원을 위해 알파(alpha)값을 사용한다.
    RGBA라는 RGB에 Alpha 값을 추가해 참조한다.

    색상 버퍼(color buffer)는 전체 화면의 색상 정보를 포함하고 있는
    메모상의 위치이다.
    각 (x,y)인덱스가 화면상의 픽셀과 일치하는 배열로 생각하면 된다.

    색상 버퍼의 메모리 사용률은 각 픽셀이 사용한 비트의 수에 의존한다.
    일반적인 24bit 색상 깊이(color depth)에서 RGB는 각각 8비트를 사용해
    2^24 또는 16,777,216개의 색깔을 표현할 수 있다는 뜻이다.
    Alpha의 8bit를 포함하면 픽셀당 32bits 크기를 가지게 된다.
    (1920x1080x4byte = 7.9MB, 1080p)
    8bits 이상의 16bits 색상을 지원하는 디스플레이도 존재한다.

    색상이 주어졌을 때 이 값을 참조하는 방법은 2가지이다.

    1. 각 색상(채널)의 비트 수와 일치하는 부호 없는 정수 사용
        - 채널당 8비트 색상 깊이에서 각 채널은 0~255의 값을 가지고 있다.

    2. 십진수 값을 0.0에서 1.0 범위의 값을 가지도록 정규화

    더블 버퍼링

    화면 재생 빈도(refresh rate)또는 디스플레이가 갱싱하는 주파수(59.94HZ, 144HZ)는
    게임의 프레임 레이트(FPS)와 다를 수 있다.

    그리고 디스플레이는 한순간에 전체 화면을 갱신하는게 아닌
    행과 행, 열과 열, 바둑판 형태, 기타 등등의 갱신 순서가 있다.
    어떤 패턴을 사용하든 전체 화면 갱신은 약간의 시간이 걸린다.

    즉, 게임 프레임 레이트의 타이밍이 모니터의 화면 재생 빈도와 일치하지
    않는 경우 게임이 버퍼에 쓰는 중에 디스플레이가 색상 버퍼로부터 데이터를 읽는
    상황이 발생할 수 있다.

    이 문제는 스크린 테어링(screen tearing)이 발생할 수 있다.
    (화면이 찢어져 보이는 형상)
    (프레임 A에서 색상 버퍼를 쓰고 디스플레이가 색상 버퍼를 읽는 도중
    프레임 B에 대한 색상 버퍼를 덮어씌우면 A와 B프레임이 겹치게 된다.)

    Screen Trearing 제거하기
    1.  게임과 디스플레이가 공유해야 하는 색상 버퍼를 한 개보단
        별도의 두 색상 버퍼로 생성한다.

        두 버퍼로 게임은 한 버퍼(back buffer)에 쓰고, 동시에 디스플레이는 
        다른 버퍼(front buffer)에서 읽는다는게 기본 아이디어이다.

    2.  게임과 디스플레이는 프레임마다 색상 버퍼를 교대로 사용한다.

    두 개의 색상 버퍼를 사용해 더블 버퍼링(double buffering)이라 부른다.

    하지만 게임의 업데이트가 너무 따른 경우 여전히 충돌이 나 문제가 발생한다.
    해결책은 디스플레이가 버퍼를 교환하기 전에 자신이 사용하고 있는
    버퍼를 모두 그릴 때까지 게임이 기다리는 것이다.

    이것을 수직 동기화(vertical synchronization) 또는 화면 갱신 때
    모니터가 보내는 신호의 이름을 따 vsync라 부른다.

    하지만 수직 동기화와 vsync는 짧은 시간 대기가 필요해 프레임 레이트가 저하될 수 있다.
    엔진에서 옵션으로 제공해 가끔 발생하는 screen tearing이나 버벅거림 조정을 선택할 수 있으면
    좋다.

    최근엔 적응적 화면 재생 빈도(Adaptive refresh rate)로 이 딜레마에 대한
    해결책을 찾고 있따.
    이 방법은 디스플레이가 화면 갱신을 통지하기보단 게임이 디스플레이로
    화면 갱신을 언제할지 알려준다.
    게임과 디스플레이의 동기화가 가능해 문제를 해결한다.

    고수준에서 게임용 그래픽 라이브러리로 그래픽을 그리기

    1. back buffer를 단색으로 클리어(게임의 현재 버퍼)
    2. 전체 게임 장면 그리기
    3. front buffer와 back buffer 교환

    게임 갱신

    약 30FPS로 진행되는 게임은 한 프레임에서 다음 프레임까지 33ms가 걸린다.

    현실세계에서 걸린 시간인 실제 시간과 게임 세계에서 걸린 시간인 게임 시간(Game time)을 구별하는 게 중요하다
    (중간에 게임을 정지하거나, 게임의 속도를 줄이는 불릿타임 효과, 30분짜리 풋볼게임을 실제로는 15분만에 끝내기 등등)

    초창기엔 특정 트로세서 속도와 특정 프레임 레이트를 가정하고 프로그래밍 했었다.
    (ex: 8MHZ 프로세서를 가정하고 코드를 작성)

    고정된 프레임 레이트라 가정하면 적의 위치를 갱신하는 건 다음과 같다.
    enemy.mPosition.x += 5; // x좌표에 5픽셀을 더해 갱신

    하지만 현대 프로세서는 매우 빠르기에 델타 시간(Delta time)을 사용한다.
    delta time은 마지막 프레임 이후로 경과된 게임 시간을 뜻한다.
    즉, 프레임마다 픽셀 이동을 생각하는 게 하닌 초당 픽셀 이동을 생각한다
    enemy.mPosition.x += 15- * deltaTime // 초당 150픽셀식 x위치 갱신

    프레임 레이트에 상관없이 잘 동작한다.
    30FPS에서 delta time은 ~0.033이므로 5픽셀 이동하고 초당 150픽셀 이동한다.
    60FPS에선 프레임당 2.5픽셀, 초당 150픽셀 이동한다.
    즉 훨씬 부드러워 진다.

    시스템이 허용하는 프레임 레이트로 게임을 진행하면 좋다고 생각하지만
    문제가 발생한다. 
    특히 물리 시스템은 프레임 레이트에 따라 동작에 차이가 발생할 수 있다.

    해결법 중 가장 간단한 방법은 프레임 제한(frame limit)을 구현하는 것이다.
    프레임을 제한하면 게임 루프를 목표 delta time이 경과할 때 까지 기다리도록 강제한다.

    ex: 목표 프레임 = 60FPS, 프레임이 단 15ms만에 완료되면
        게임 루프는 목표 delta time 16.6ms를 충족하기 위해 ~1.6ms를 추가로 기다린다.

    너무큰 델타 시간도 주의해야 한다.
    디버거(Debuger)에서 게임 코드를 단계별로 실행하면 발생할 수 있다.
    
    ex: 5초 동안 프로세스 정지 시 매우 큰 델타 시간을 가져, 예상치를 초과해 더 앞으로 점프하게 된다.
    
    이 문제는 델타 시간을 0.05같은 최대값으로 고정하면 된다.
        
*/