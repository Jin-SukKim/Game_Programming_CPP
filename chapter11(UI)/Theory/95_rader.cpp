/*
    
    레이더 추가

    플레이어 기준 특정 반경 이내의 근처에 있는 적(또는 다른 물체)들을 보여주기 위한 레이더가 있다.
    레이더상에 있는 적들은 점이나 원처럼 보이는 신호(blips)로 표현할 수 있따.

    레이더 작동 구현은 두 파트로 나뉜다.
    먼저 레이더상에 나타나는 액터의 추적이 필요하다.
    그리고 프레임마다 플레이어에 상대적인 액터의 위치를 기반으로 레이더상의 신호를 갱신한다.
    
    가장 기초적인 접근법은 레이더 중심으로부터 Vector2d 오프셋 형식으로 신호를 나타낸다.
    또한 다양한 텍스처로 신호의 다른 특성을 추가하면 좋다.

    TargetComponent를 가진 액터는 레이더 범위 내라면 포착되게 한다.
    이를 위해 HUD에 레이더를 위한 변수를 추가한다.
    // 레이더에 상대적인 신호의 2D 오프셋
    std::vector<Vector2d> mBlips;
    // 레이더의 범위, 반지름값
    float mRadarRange;
    float mRadarRadius;
    
    mBlips 벡터는 레이더 중심에서 상대적인 신호들의 2D 오프셋을 기록한다.
    레이더 갱신 시 mBlips도 갱신된다.

    레이더를 그릴 때는 배경을 먼저 그린 뒤 신호들의 2D 오프셋을 사용해 신호 텍스처를 그린다.

    레이더 범위는 세계를 레이더가 얼마나 멀리 볼 수 있는지를 나타낸다.
    ex) 2000범위 = 세계 공간에서 2000단위의 범위를 인식
    반지름 변수는 화면상에 그려질 2D 레이더의 반경값이다.

    게임에 50단위의 범위를 가진 레이더가 있고 플레이어 바로 앞 25단위에 물체가 있다면
    오브젝트 위치는 3D상에 있지만 플레이어의 위치와 물체 모두 화면 레이더상의 2D 좌표로 변환해야 한다.
    z축이 상향 벡터인 세계는 x-y 평면상으로 플레이어와 오브젝트가 투영된다는 의미다.
    즉 레이더는 레이더가 추적하는 플레이어와 오브젝트의 z 요소를 무시한다.

    레이더는 세계 공간에서 항상 전방을 가리키며 게임 세계는 +x가 전방이므로
    z 요소만을 무시하는 것만으로 충분하지 않다.
    레이더에 플레이어와 액터를 제대로 나타내려면 (x, y, z) 좌표를 레이더 오프셋
    표현인 2D 벡터 (y, x)로 전환해야 한다.

    프렐리어와 오브젝트의 위치로부터 각각 2D 레이더 좌표를 얻으면 플레이어에서
    오브젝트로의 벡터 a를 구할 수 있다.
    a의길이는 물체가 레이더 범위 안에 있는지를 결정한다.
    a를 레이더의 최대 범위값으로 나누면 레이더 반지름에 대한 오브젝트 오프셋의 비율을 구할수있따.
    이 값에 레이더의 반지름을 곱해새로운 벡터 r을 구한다.

    r = RadarRadius(a / RadarRange), a = 플레이어에서 오브젝트로의 벡터

    그런데 대부분의 레이더는 플레이어가 회전할 때 같이 회전하므로 레이더상의 위쪽은
    게임 세계에서 항상 전방과 일치한다.
    이는 레이더 신호의 오프셋으로 r을 바로 사용할 수 없다는 뜻이다.
    그래서 플레이어 전방 벡터의 x-y 평면 투영과 세계의 전방(x 방향) 사이의 각도를 알아야한다.
    atan2를 사용해 각도를 구한다.
    이 각도로 2D 회전 행렬을 구축한다.

    Rotation2D(각도) = | cos각도    sin각도 |
                       | -sin각도   cos각도 |

    액터의 최종적인 신호 오프셋은 방금 얻은 행렬로 회전시킨 벡터 r이다.

    BlipOffset = r * Rotation2D(각도)

    HUD::Update에서 이 방정식을 사용해 레이더를 동작하게 만든다.

    레이더를 그리기 위해 먼저 배경을 그린 후 각 신호를 순회하며 신호를 레이더 중심 + 신호의 오프셋 위치에 그린다.
    적이 플레이어 위에 있는지 아래에 있는지 또한 나타내기 위해선 z 요소를 포함해서 전환해줘야 한다.

*/

