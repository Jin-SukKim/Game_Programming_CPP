/*
    정지 메뉴

    게임이 정지 상태를 지원하므로 정지 메뉴를 추가한다.
    서브클래스 PauseMenu를 선언한다.
    PauseMenu의 생성자는 게임 상태를 정지로 설정하고 UI 스크린의 제목 텍스트를 설정한다.

    소멸자에서는 게임플레이로 되돌아가도록 게임 상태를 EGameplay로 지정한다.
    마지막으로 HandleKeyPress 함수에서는 esc 키를 누르면 정지 메뉴를 닫도록 구현한다.

    이 부분은 PauseMenu 인스턴스를 삭제하게만든다.
    인스턴스가 삭제되면 PauseMenu의소멸자가 호출되며 소멸자는 게임 상태를 게임플레이
    상태로 전환해 게임ㅇ르 계속 진행할 수 있게 해준다.

    정지 메뉴를 보기 위해선 UIScreen의 생성자가 자동으로 스택에 추가하므로
    새로운 PauseMenu 객체를 생성하면 된다.

    버튼

    게임에서 대부분의 메뉴는 플레이어와 상호작용 가능한 버튼이 있다.
    여러 UI스크린은 버튼이 필요하므로 기본 UIScreen 클래스로 버튼을 추가하는 것이 합당하다.

    버튼 캡슐화를 위해 Button 클래스를 선언한다.
    모든 버튼은 텍스트 이름을 가진다고 가정해 텍스트 렝더링을 위한 Font 포인터가 필요하다.
    화면상의 위치와 차원(너비와 높이)를 가진다.
    마지막으로 버튼을 클릭 시 특정 액션을 수행하야 한다.

    버튼 액션의 커스터마이징을 위해 std::function 클래스를 사용해 콜백 함수를 캡슐화한다.
    이 함수는 독립형 함수이거나 일반적으로 람다 표현식이다.
    Button을 선언할 때 생성자는 이 콜백함수를 파라미터로 받는다.

    주어진 점이 버튼의 2D 경계 내부에 있으면 true를 리턴하는 ContainsPoint 함수를 구현한다.
    충돌 감지에서 점이 경계 내에 있지 않은 4가지 경우에 대한 테스트를 한 것과 같은 접근법을 사용한다.
    4가지 경우 중 하나라도 true가 아니면 버튼은 점을 포함한다.

    버튼의 생성자로 받은 function의 핸들러가 존재하면 클릭 시 작동하게 할 OnClick() 함수를 생성한다.

    UIScreen에 버튼을 지원하도록 멤버 변수를 추가한다.

    1. Button 포인터 맵
    2. 버튼을 위한 2개의 텍스터

    텍스처 중 하나는 버튼이 선택되지 않았을 때의 텍스처이고,
    다른 하나는 선택됐을 때의 버튼이다.

    버튼은 마우스를 사용해 클릭하는데 게임에서 상대 마우스를 사용해 회전한다.
    그래서 플레이어가 버튼을 클릭하려면 상대 마우스 모드를 비활성화해야 한다.
    이 비활성화는 PauseMenu 클래스에서 해준다.
    생성자에서 비활성화, 소멸자에서 활성화시킨다.

    다이얼로그 박스

    특정 메뉴 액션에는 플레이어에게 확인 다이얼로그 박스를 보여주는 것이 좋다.
    이러면 플레이어가 실수로 버튼을 클릭해도 실수를 바로잡을 여지가 있다.
    UI 스크린 스택은 하나의 UI 스크린에서 다이얼로그 박스로 제어를 이동시키는 것이 쉽다.

    조준망 추가

    대부분의 1인칭 게임은 화면 중간에 조준망을 가지고 있다.
    다른 물체를 겨냥하면 다른 텍스처로 바뀌기도 한다.

    지금은 목표물 중 하나를 겨냥할 때 빨간색으로 변하게 구현한다.
    // 십자선 텍스처
    class Texture* mCrosshair;
    class Texture* mCrosshairEnemy;
    // 적을 조준하는 지
    bool mTargetEnemy

    대상이 되는 목표물을 구별할 수 있도록 TargetComponent라는 새 컴포넌트를 생성한다.
    그 후 HUD의 멤버 변수로 TargetComponent 포인텅 ㅔ대한 벡터를 선언한다.

    HUD에서 적을 바라보는지 알기 위해 UpdateCrosshair 함수를 구현한다.
    GetScreenDirection 함수를 사용해 카메라가 현재 바라보는 곳의 정규화된 벡터를 반환받고
    이 벡터와 상수를 사용해서 선분을 만들어 선분과 교차하는 최초의 액터를 찾기 위한
    SegmentCast 함수를 사용한다.

    그 후 액터가 TargetComponent인지 판단한다.
    현재는 mTargetComps에 있는 TargetComponent의 소유자가 선분 캐스트를 통해
    알아낸 액터와 동일하는지를 파악하지만 액터가 어떤 컴포넌트를 가지고 있는지
    찾는 방법을 구현하면 최적화가 가능해진다.

*/