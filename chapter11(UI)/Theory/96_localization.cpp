/*
    현지화(localization)

    현지화는 게임을 한 지역에서 다른 지역으로 상황에 맞게 변환하는 과정을 뜻한다.
    가장 일밙겅니 항목은 화면상에 보여주는 텍스트와 텍스트에 맞는 음성이다.

    지역화는 프로그래머도 작업을 해줘야 하는데 UI의 경우 화면상에 여러 로케일(locale)로
    테스트를 쉽게 보여주는 시스템을 구축해줘야 한다.
    즉, 문자열이 하드 코딩이 아닌, "QuitText"같은 키와 화면에 출력되는 실제 텍스트 간의 변환을 위한 맵이 필요하다.

    유니코드로 작업하기

    텍스트 현지화의 한가지 문제점은 ASCII 문자 각각은 내부적으로 1바이트로 저장되지만
    실제로는 7비트 정보만 가지는데 있다.
    7비트 정보뿐만이라는 것은 문자가 전체 128개라는 것을 의미한다.
    52개는 영어 대소문자, 문자의 나머지는 숫자나 기호다.
    ASCII는 다른 언어의 글리프(glyph)를 포함하지 않느다.

    이를 해결하기 위해 Unicode가 나왔다.
    현재 버전의 유니코드는 이모지(emoji)뿐만 아닌 다양한 언어의 글리프를 포함해
    10만 개 이상의 다양한 글리프를 지원한다.
    
    단일 바이트는 256개의 구별된 값 이상 표현은 불가능하므로 유니코드는
    여러 바이트를 사용한 인코딩 방법을 고려한다.

    1. 문자가 2byte/4byte 포함하는 몇가지 인코딩 방식
    2. 가장 인기 있는 UTF-8 방법

    UTF-8은 문자열의 각 문자가 1에서 4바이트 사이의 다양한 길이를 가진다.
    각 문자의 크기가 고정된 인코딩보다 다루기가 좀 더 복잡해보이지만
    ASCII와 완전히 하위 호환이 된다.

    즉, ASCII의 byte sequence가 UTF-8의 시퀀스와 동일하다.
    UTF-8의 문자가 1바이트인 경우는 ASCII로 간주한다.
    하위 호환성은 UTF-8이 JSON과 같은 파일 포맷뿐만 아닌 www의 기본 이코딩 방법인 이유다.

    하지만 C++는 유니코드에 대한 내장기능이 많이 없다.
    std::string 의 경우 ASCII 문자만을 대상으로 하고 UTF-8로 저장해 유니코드로 활용은 가능하지만
    글리프(문자)의 수를 제대로 알려주지 않는다. length는 저장된 바이트의 수를 알려준다.
    
    RapidJSON과 SDL_TTF는 UTF-8 인코딩을 지원한다.
    즉, std::string에 UTF-8로 저장한뒤 두 라이브러리와 연동해 사용하면 추가 코드 없이 지원 가능하다.

    텍스트 맵 추가하기

    Game에 키와 값이 std::string인 unordered_map 타입의 mTextMap 변수를 추가한다.
    이 맵은 "QuitText"와 같은 키를 "종료하시겠습니까?"같은 화면ㅇ에 표시되는 텍스트와 매핑된다.
    이 맵은 JSON 파일 포맷으로 정의 가능하다.
    모든 언어는 그 언어만의 JSON파일을 가지며 이를 통해 다른 언어 간 전환을 지원한다.
    (English.gptext)

    gptext 파일을 parsing하고 mTextmap에 내용을 채우는 LoadText 함수를 추가해준다.

    비슷하게 게임에서 키가 주어졌을 때 관련 텍스트를 반환하는 GetText 함수도 구현한다.
    텍스트 맵에서 찾기만 수행한다.

    Font::RenderText에서 2가지를 수정한다.
    파라미터로 얻은 텍스트 문자열을 직접 렌더링하지 않고 텍스트 맵에서 텍스트 문자열을 찾도록 수정한다.
    그 후 TTF_RenderText_Blended를 호출하는 대신 TTF_RenderUFT8_Blended를 호출한다.

    마지막으로 하드 코딩된 텍스트 문자열을 사용한 일부 코드를 텍스트 키를 사용하는 형태로 변경한다.
    ex) 정지 메뉴의 제목키 = "PAUSED"가 아닌 "PauseTitle"이 된다.

    기타 현지화 이슈

    이번에 공부한 코드는 트루타입 폰트가 모든 글리프를 지원하는 경우에만 정상 작동한다.
    그런데 현실적으로 폰트 파일은 글리프의 일부분만을 포함하는 것이 일반적이다.
    중국어 같은 일부 언어는 일반적으로 해당 언어 전용의 폰트 파일을 가진다.

    이 문제 해결하려면 gptext 파일에 폰트 엔트리를 추가해야 한다.
    또한 mTextMap 구축 시 올바른 폰트를 로드하고 UI 코드의 나머지는 올바른 폰트 사용을 보장해야 한다.

    또한 각 언어의 길이가 다른 경우도 있다. 독일어는 영어텍스트보다 20% 정도 일반적으로 더 길다.
    이 문제를 해결하려면 항상 렌더링된 폰트 텍스처의 크기를 알아내서 크기 조절을 해야한다.

    마지막으로 일부 상황에서 텍스트나 대사 또는 리소스 전반에 걸쳐 콘텐츠 현지화 작업이 필요할 수도 있다.
    ex) 일부 게임은 중국에서 콘텐츠 제한을 많이 받는다.
        독일에서 제3제국과 관련된 심벌을 포함한 제품 판매는 불법이다.
    이런 유형은 아티스트가 해당 지역에 대안 콘텐츠를 제작해 해결할 수 있다.

*/