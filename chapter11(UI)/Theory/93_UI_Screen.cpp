/*
    UI 스크린

    UI 시스템은 HUD나 메뉴 등 여러 경우에 사용될 수 있어 유연성이 중요하다.
    비록 어도브 플래시 같은 툴이 사용하는 데이터 주도 잇스템이 있지만,
    지금은 코드 기반 구형에 초점을 맞춘다.
    이 챕터에서 공부하는 아이디어는 데이터 주도 시스템에도 적용할 수 있다.

    UI는 여러 레이어를 포함한 것이다.

    HUD(Head-Up Display)는 게임 동안 체력, 점수 같은 플레이어와 과ㅏㄴ련된 정보를 보여준다
    플레이어가 게임을 정지시 게임은 여러 옵션을 플레이어가 선택하도록 메뉴를 보여준다.
    정지 메뉴를 보여주는 동안에도 여전히 정지 메뉴 아래 HUD 요소가 보이길 원할수도 있따.

    정지 메뉴 옵션 중 하나로 게임 끝내기가 있을 시 플레이어가 이 옵션을 선택하면
    정말 게임을 종료할지 묻는 확인용 다이얼로그 박스가 뜬다.
    플레이어는 여전히 다이얼로그 박스 아래 HUD나 정지 메뉴를 볼 수 있다.

    플레이어는 일반적으로 이 과정 동안 UI의 최상 레이어하고만 상호작용을 할 수 있다.
    이는 자연히 UI를 여러 레이어로 구성된 스택의 사용으로 이끈다.

    단일 UI 레이어는 UIScreen 클래스로 구현한다.
    정지 메뉴, HUD 같은 UI 스크린 각각의 타입은 UIScreen의 서브클래스다.

    게임은 상향순으로 스택상의 모든 UI 스크린을 그린다.
    특정 시점에서는 오직 UI 스택 상단의 UIScreen만이 입력 이벤트를 받을 수 있다.

    기본 UIScreen 클래스의 가상 함수

    1. Update : UI 스크린의 상태를 갱신
    2. Draw : 화면에 그린다.
    3. ProcessInput, HandleKeyPress : 여러 타입의 입력을 다루는 입력 처리 함수

    또한 UI 스크린의 특정 상태도 추적 가능한데 UIScreen의 경우 오직 스크린이 활성화됐는지
    닫혔는지에 댛나 2가지 상태만이 필요하다.

    제목도 있으므로 멤버 데이터는 Font에 대한 포인터, 렌더링된 제목을 포함하는 텍스터,
    화면상에서의 제목 위치 정보를 가진다.

    UIScreen은 액터가 아니기에 컴포넌트 타입을 붙일 수 없다.
    UIScreen 클래스는 SpriteComponent의 그리기 기능이 아닌 화면상의 특정 위치에
    텍스처를 그리는 DrawTexture라는 새로운 헬퍼함수를 생성해 사용한다.

    UI 스크린 스택

    UI 스택 구성을 위해 UIScreen 포인터 벡터를 Game 클래스에 추가한다.
    std::stack을 사용하지 않는데 전체 UI 스택을 반복하면서 조회할 필요가 있는데
    std::stack은 불가능해서이다.
    새로운 UIScreen을 스택에 추가하는 PushUI 함수를 구현한다.
    그리고 참조로 스택을 얻어내는 함수도 추가한다.

    UIScreen의 생성자는 PushUI를 호출하고 this 포인터를 전달한다.
    즉 UIScreen과 서브클래스들을 동적으로 할당하면 자동으로 스택에 추가된다.

    UI 스크린 갱신은 UpdateGame 함수에서 게임 세계상의 모든 액터가 갱신된 후에 일어난다.

    UI 스크린을 그리는 작업은 렌더러에서 수행한다.
    Renderer::Draw 함수는 메시 셰이더를 사용해 3D 메시 컴포넌트를 그린 뒤
    스프라이트 셰이더를 사용해 모든 스프라이트 컴포넌트를 그렸다.
    UI는 텍스처로 구성되있으므로 sprite shader로 UI를 그린다.
    렌더러는 모든 spritecomponent를 그린후 UI 스택을 얻어 그려준다.

    UI 스택에서 입력을 다루는 것은 조금 까다롭다.
    대부분의 경우 마우스를 클릭하는 특정한 입력 액션은 게임이나 UIㅇ 영향을 주지만,
    둘 동시에 여향을 미치지는 않는다.
    그러므로 우선 입력이 게임 또는 UI로 전달되는지를 결정할 방법이 필요하다.

    이를 위해 3가지으 ㅣ다른 상태를 갖는 mGameState 변수를 Game에 추가한다.

    1. 게임 플레이
    2. 정지
    3. 나가기

    게임플레이 상태에서 모든 입력 액션은 게임 세계로 전달되며,
    이는 각 액터로 입력을 전달된다.
    정지 상태의 모든 입력 액션은 UI 스택의 상단에 잇는 UI 스크린에 전달된다.
    즉, Game::ProcessInput은 각 액터나 또는 UI 스크린의 ProcessInput 함수를 호출해야한다.

    이 과정을 확장해 UI 스택 상단에 있는 UI 스크린이 입력의처리 유무를 결정하게 만들 수 잇다.
    UI 스크린이 입력 처리를 원치 않으면 해당 입력ㅇ르 스택상에 있는 다음 최상단 UI로 포워딩한다.

    비슷하게 SDL_KEYDOWN이나 SDL_MOUSEBUTTON 이벤트가 발생시 이벤트를 게임 세계나
    스택 상단의 UI 스크린으로 보낸다.

    게임 상태 추적을 위해 mGameState 변수를 추가했으므로 게임 루프도 변경이 필요하다.
    게임이 EQuit 상태가 아닌 한 루프 상태를 유지한다.
    게임 상태가 오직 EGamePlay인 경우에만 모든 액터에 Update를 호출하도록 수정한다.
    정지 상태에서는 오브젝트를 갱신하지 않는다.

*/