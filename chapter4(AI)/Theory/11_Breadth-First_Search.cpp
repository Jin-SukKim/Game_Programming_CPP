/*
    너비 우선 탐색(Breadth-First Search, BFS) (BFS 함수)

    이 알고리즘은 가까운 노드에서 목표를 찾아본 후 없다면
    그 후에 더 먼 노드를 찾아보는 방식이다.
    (루트 노드 혹은 임의의 노드에서 시작해 인접한 노드를 먼저 탐색하는 방법)

    BFS 알고리즘은 edge에 가중치가 없거나 모든 edge가 양의 같은 가중치(weight)을
    가질 경우 최단 경로를 찾는 것을 보장한다.

    알고리즘을 수행하는 동안 몇 가지 데이터를 기록하면 최소한의 이동 횟수로
    경로를 재구성할 수 있따.

    BFS 동안 각 노드는 직전에 방문한 노드를 알아야 한다.
    부모(Parent) 노드라 불리는 행당 노드는 BFS가 완료된 후 경로를 재구성하는 데 필요하다.
    GraphNode 구조체에 추가하는 것보단 데이터가 변경되지 않도록 분리하는 것이 좋다.
    이 부모 노드는 시작 노드와 목표 노드에 따라 변하기 때문이다.
    또한 데이터를 분리하면 멀티 스레드를 통해 동시에 몇 개의 경로를 계산할 경우
    각 탐색이 서로간에 간섭하지 않는 것을 보장할 수 있따.

    사각 타일 맵은 가중치가 필요가 없어 BFS 구현이 가능하다.(NodeToParentMap)

    BFS를 구현법

    가장 간단한 방법은 queue의 사용이다.
    큐는 FIFO 행동을 한다.
    
    1. 먼저 시작 노드를 큐에 추가하고 루프에 진입한다.
    2. 각 반복에서 큐로부터 노드를 꺼낸 뒤 목표에 도달했는지 확인한다.
    3. 해당 노드의 이웃 노드들을 꺼내 부모 맵을 확인함으로써 이미 검사한 노드를 큐에 다시 추가하는 걸 피할 수 있다.
        - 큐에서 꺼낸 노드의 이웃 노드는 자신의 부모가 등록돼 있는지 조회하고
          이미 맵에 존재한다면 큐에 추가하지 않고 없다면 노드맵에 부모를 등록하고 자신을 큐에 추가한다.
    4. 시작 노드와 목표 노드 사이에 어떤 경로도 존재하지 않는다면 루프는 종료할 것이다.
        - 모든 노드를 검사했기에 가능성이 소진됐으므로 큐는 비게되고 루프는 종료한다.

    BFS가 성공하면 outMap의 부모 포인터를 사용해 경로 재구축이 가능하다.
    경로상에서 목표 노드의 상위 노드는 선행 노드를 가리키기 때문이다.
    그러면 목표점에서 시작점까지의 경로를 얻게된다.

    하지만 시작점에서 목표점까지의 경로를 원하므로 stack을 사용해 경로를 반전시킬수도 있지만
    탐색 자체를 반전시키는 것이 더 좋다.
    즉 start 노드를 목표로 goal 노드를 시작 노드를 전달한다.

    BFS는 경로가 존재한다면 경로를 항상 발견한다.
    하지만 edge의 가중치를 고려하지 않기에 가중 그래프에서 최단 경로의 발견을 보장하지 않는다.
    BFS에서 모든 edge의 이동값은 같다.
    (ex: 4개읜 노드를 지나는 경로의 가중치의 합이 더 작아 최단 경로이지만, 
         BFS는 2개의 노드를 지나는 경로를 반환한다.)

    또 다른 문제점은 노드가 목표 노드의 반대 방향에 있더라도 노드를 테스트하는 데있다.
    좀 더 복잡한 알고리즘을 적용하면 최적의 답을 찾는 과정에서 테스트할 노드의 수를
    중리는 것이 가능하다.

*/