/*
    (Pathfinding.cpp)
    길 찾기(Pathfinding) 알고리즘 - 두 지점의 경로상에 있는 장애물을 피해서 길을 찾는다.

    복잡성 : 두 점 사잉에는 여러 다양한 경로 집합이 존재할 수 있다.
    이 경로들 중 아주 적은 수의 경로만이 최단 경로다.

    즉 최단 경로를 찾기 위해서 모든 가능한 경로를 효율적으로 탐색하는 방법이 필요하다.

    그래프(GraphNode, Graph, WeightedEdge, WeightedEdge, WeightedGraph structure)

    문제를 풀기위해 보통 그래프(graph) 데이터 구조를 통해 AI가 통과할 수 있느 겡미 세계의 부분을 표현해준다.

    그래프는 일련의 노드(node)를 포함한다.
    이 노드는 에지(edge)를 통해 서로 연결된다.
    이 edge에 방향성이 없는 경우가 있는데 이 경우는 양 방향으로 이동할 수 있다는 걸 의미한다.
    방향성이 있다는 것은 edge가 오직 한 방향으로 이동할 수 있다는 것이다.

    edge는 선택적으로 관련된 가중치(weight)를 가질 수 있는데, 가중치는 edge를 이동하는데 드는 비용이다.
    게임에서 가중치는 노드 사이의 최소한의 거리를 뜻하지만 edge를 이동하는 것의
    난이도를 뜻할 수도 있따.
    (모래더미를 지나는 것과 콘트리트를 이동하는 값은 가중치가 다르다.)

    가중치가 없는 그래프(균일 그래프)는 모든 에지의 가중치가 일정한 그래프다.

    메모리상에 그래프를 나타내는 다양한 방법 중 인접 리스트(adjacency list)를 사용한다. (LinkedList와 vector을 이용해서 표현)
    각 노드는 std::vector를 사용해 인접 노드 컬렉션을 가진다.
    그래프는 이 노드의 집합이다.

    가중 그래프에서 각 노드는 연결된 노드 리스트 대신 외부로 향하는 에지를 저장한다.
    edge의 '시작'과 '끝'을 참조하면 노드 A에서 B로 향하는 방향성 있는 edge의 지원이 가능하다.
    이 경우 노드 B의 mEdges 벡터가 아닌 노드 A의 mEdges 벡터에 에지를 추가해야한다.

    방향성 없는 edge를 원한다면 간단히 각 방향별로 하나씩해서 2개의 방향성 있는
    edge를 추가하면된다. (A->B, B->A)

    그래프를 통해 게임 세계는 나타내는 방법은 많다.
    격자 형태의 사각형으로 분할하는 것은 매우 일반적이다.
    이번 프로젝트에서는 격자 형태의 사각형으로 표현하지만 이 방법이 맞지 않을수도 잇다.

*/