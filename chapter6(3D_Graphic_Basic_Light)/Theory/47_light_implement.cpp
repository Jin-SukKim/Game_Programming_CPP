/*
    조명 구현

    주변광과 방향광을 구현하려면 vertex/fragment shader의 수정이 필요하다.

    조명ㅇㅣ픽셀 단위이므로 phong fragment shader는 추가로 몇 개의 uniform이 필요하다.(Phong.frag)

    1. 카메라 위치
    2. 주변광 색상
    3. 방향광을 위한 변수

    GLSL은 c/c++처럼 구조체를 지원한다.
    GLSL과 C++ 모두 구조체를 선언해준다.
    struct을 이용해 DirectionalLight 선언을 하고 주변광과 방향광에 대한
    변수를 Renderer 클래스에 추가한다.

    glUniform3fv와 glUniform1f 함수는 3D 벡터와 float uniform을 각각 설정한다.
    Shader클래스에 2개의 새로운 Set 함수를 만들어 사용한다.

    구조체의 특정 멤버를 참조하기 위해선 . 표기법을 사용하면 된다.
    uDirLight.mDirection 등(GLSL, C++ 동일)

    뷰 행렬에서 카메라 위치를 얻어내려면 뷰 행렬의 역행렬을 구해야 한다.
    역행렬을 구한 후 네 번째 행의 처음 3요소(GetTranslation 멤버 함수로 반환)가
    카메라의 세계 공간의 위치에 해당한다.

    다음으로 gpmesh 파일 포맷을 갱신해서 specularPower 속성을 가진 메시 표면의
    정반사 지수(specular power)를 지정한다.
    이 속성을 읽을 수 있도록 Mesh::Load 함수를 갱신한 후 메시를 그리기 전
    MeshComponent::Draw에서 uSpecPower uniform을 설정한다.

    vertex shader도 변경이 필요하다.
    카메라 위치와 방향광의 위치는 모두 세계 공간에 있다.
    하지만 vertex shader에서 계산된 gl_Position은 클립 공간에 있다
    표면에서 카메라로 향하는 올바른 벡터를 얻으려면 세계 공간상의 위치가 필요하다.
    또한 입력 vertex 법선은 오브젝트 공간에 있다.
    하지만 이 vertex 법선도 세계 공간에서 필요하다.
    그래서 vertex shader는 세계 공간의 법선과 세계 공간의 위치를 계산해서
    이 값들을 out 변수를 통해 fragment shader로 보내야한다.

    그래서 fragment에서 변수들을 받은 세계 공간에서의 법선과 위치를 계산한다.
    swizzle이라 알려진 .xyz 문법은 4D 벡터에서 x, y, z요소를 추출하고 
    이 값으로 새로운 3D 벡터를 생성한다.
    이 기능은 vec4와 vec3를 효율적으로 변환한다.

    코드는 법선을 동차 좌표로 변환해서 세계 변환 행렬과 곱셈이 되도록 한다.
    법선은 위치가 아니라 벡터이기에 w는 1이 아닌 0이다.

    fragment shader는 퐁 반사 모델을 계산한다.
    fragNormal 법선은 정규화된다.
    OpenGL이 삼각형의 전 표면에 걸쳐 해당 픽셀의 법선 벡터를 얻기 위해 삼각형에
    있는 vertex의 법선 벡터들을 보간하는데, 보간의 각 단계에서 두 정규화된 벡터를
    보간할 시 그 결과는 정규화된 벡터를 보장해주지 않는다.
    따라서 보간을 통해 얻은 벡터는 재정규화 해야한다.

    방향광은 한 방향에서 발산하므로 표면에서 광원으로 향하는 벡터는
    광원 벡터를 반전시키면 된다.

    GLSL 함수중 dot 함수를 사용해 내적을 계산하며 reflect는 반사 벡터를 계산한다.
    max는 최대값, pow는 지수값, clamp 함수는 벡터에 전달된 각 요소의 값을
    지정된 범위값으로 제한한다.
    이 경우 조명값은 0.0(빛 없음)에서 1.0(해당 색상의 최대 조명)까지이다.
    
    최종 색은 텍스처 색상과 퐁 관원의 곱이다.

    R과 V의 내적이 음수라면 비정상적인 경우가 발생하는데
    정반사 요소가 음수라서 장면으로부터 빛을 없애버릴 수 있다.
    max 함수 호출은 내적이 음수라면 0을 선택하기에 이 문제를 막아준다.
*/