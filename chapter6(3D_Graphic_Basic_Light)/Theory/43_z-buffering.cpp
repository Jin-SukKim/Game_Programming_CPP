/*
    챕터 2에서 화가 알고리즘을 공부했었다.
    이 알고리즘은 오브젝트를 뒤에서부터 앞으로 그렸었다.
    하지만 3D 게임에서는 잘 작동하지 않는다.

    근본적인 문제점은 3D 게임에서는 앞뒤 정렬 순서가 정적이지 않다는 것이다.
    카메라의 위치와 회전에 경우 물체의위치도 매번 변경되 화가 알고리즘을
    사용하기 위해선 매 프레임마다 모든 삼각형을 뒤에서부터 앞으로 정렬해야 한다.
    이 빈번한 정렬은 성능 병목 현상을 초래한다.

    화면 분할 게임의경우 성능 저하 현상이 더 심각해진다.

    그리고 불필요한 대량 그리기 연산을 수행하고 프레임마다 단일 픽셀에
    여러 색상을 덮어쓴느 등 맣은 문제가 있다.

    현대의 3D 게임에서 픽셀의 최종 색상을 계산하는 과정은
    렌더링 파이프라인 과정 중에서 가장 비싼 비용이 드는 부분 중 하나다.
    최종 색상 계산에 사용하는 fragment shader에는 텍스처링, 조명, 여러 테크닉을 포함하기 때문이다.
    그래서 최대한 픽셀이 다시 그려지는 걸 최대한 제거하는 것을 목표로 한다.

    마지막으로 삼각형이 겹치는 문제가 있다.
    이 경우 화가 알고리즘은 삼각형을 올바르게 그리는 분할하는 방법을 사용해야 하지만
    좋은 방법이 아니다.

    이런 수많은 문제로 3D 게임에서는 화가 알고리즘을 사용하지 않는다.

    Z 버퍼링(Z-buffering, 깊이 버퍼링)

    이 버퍼링은 렌더링 과정 동안 메모리 버퍼를 추가로 사용한다.
    z 버퍼(깊이 버퍼)로 알려진 이 버퍼는 장면의 색상 버퍼처럼 각 픽셀에
    대한 데이터를 저장한다.
    색상 버퍼가 색상 정보를 저장하는 반면, z 버퍼는 각 픽셀마다 카메라로부터
    거리(깊이)를 저장한다.

    색상 버퍼와 z 버퍼 그리고 다른 버퍼를 포함한 그래픽을 표현할 떄 필요한
    버퍼 세트를 통칭해 프레임 버퍼(frame buffer)라 불린다.

    프레임 시작시 z 버퍼를 클리어(색상 버퍼 클리어하듯)한다.
    z 버퍼는 정규화된 장치의 최대 깊이 값 1.0으로 각 픽셀을 초기화한다.
    그리고 렌더링 동안 픽셀을 그리기 전 z 버퍼링은 픽셀의 깊이를 계산한다.
    픽셀의 깊이가 z 버퍼에 저장된 현재 깊이 값보다 작다면(카메라에 더 가깝다면)
    해당 픽셀을 색상버퍼로 그린다.
    그리고 해당 픽셀의 깊이 값을 z 버퍼는 갱신한다.

    z-buffering) 의사 코드

    // zBuffer[x][y]는 해당 픽셀의 깊이 값을 가진다.
    foreach MeshComponent m in scene
        foreach Pixel p in m
            float depth = p.Depth()
            if zBuffer[p.x][p.y] < depth
                p.draw
            endif
        endfor
    endfor

    z 버퍼링 사용시 장면에서 물체의 순서가 임의로 배치된다 해도
    물체에 투명도만 없다면 제대로 보인다.
    하지만 이게 순서는 크게 상관이 없다는 뜻은 아니다.
    장면을 뒤에서 앞으로 그리면 화가 알고리즘 같이 중복 그리기를 하게 된다.
    거꾸로 장면을 앞에서 뒤로 그리면 중복 그리기는 없다.

    하지만 z 버퍼링의 이득은 어떤 임의의 순서라도 잘 동작하는 데 있다.
    z 버퍼링은 오브젝트 별로 또는 삼각형에 토대를 둔 것이 아니라 픽셀
    단위로 수행되므로 겹치는 삼각형에도 잘 동작한다.

    OpenGL은 z 버퍼링(깊이 버퍼)을 사용할 수 있도록 지원하고 있어 활성화만 해주면 된다.
    깊이 버퍼 사용시 먼저 OpenGL Context 속성 세팅할 때 깊이 버퍼를 요청한다.
    24비트가 일반적인 크기가.

    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    그리고 깊이 버퍼링을 활성화 한다.
    glEnable(GL_DEPTH_TEST);
    
    glEnable(GL_DEPTH_TEST);는 깊이 버퍼를 초기화하는데 사용되며 한 번의 호출을
    통해 색상 버퍼와 깊이 버퍼 초기와가 가능하다.

    glClear(GL_COLOR_BUGGER_BIT | GL_DEPTH_BUFFER_BIT);

    깊이 버퍼는 잘 작동하지만 몇가지 문제점이 있다.
    투명한 물체에서는 의도한 대로 z 버퍼링이 잘 동작하지 않는다.
    (ex: 바위가 물안에 있는 경우 바위 깊이 값이 더 커 그려지지 않는다)

    이 딜레마에 대한 해결책은 불투명한 오브젝트를 z 버퍼를 사용해 먼저 렌더링하는 것이다.
    그 후 깊이 버퍼 쓰기를 비활성화하고, 투명한 오브젝트를 뒤에서부터 앞으로 렌더링한다.
    픽셀이 렌더링될 때마다 불투명한 오브젝트 너머에 있는 투명한 피셀은 그려지지 않도록
    각 픽셀의 깊이를 테스트해야 한다.

    투명한 오브젝트를 렌더링할 때는 화가 알고리즘을 사용해야한다는 것이지만
    투명한 오브젝트의 수는 그렇게 많지 않을 것이다.

    이 때문에 렌더링은 두 단계에 걸쳐 진행된다.
    
    1. 알파 블렌딩은 비활성화하고 z 버퍼링은 활성화한 후 모든 3D 오브젝트를 렌더링한다.
    2. 모든 스프라이트는 알파 블렌딩을 활성화하고, z 버퍼링은 끝 채로 렌더링한다.

    그러면 모든 2D 스프라이트는 3D 장면의 제일 앞에 나타난다.
    3D 게임은 일반적으로 UI나 HUD 요소를 위해 2D 스프라이트를 사용하므로
    이렇게 해도 문제없다.

*/