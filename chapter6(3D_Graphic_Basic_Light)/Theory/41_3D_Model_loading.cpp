/*
    3D 모델 로딩

    스프라이트 기반 게임의 모든 스트라이트는 하나의 사각형으로 그리는데,
    버텍스 버퍼와 인덱스 버퍼를 하드 코딩해도 문제가 되지 않음을 뜻한다.
    하지만 3D 게임에서는 다양한 삼각형 메시가 수없이 많다.
    캐릭터 메시, 무기 메시 등을 블렌더 같은 3D 모델링 프로그램으로 만들기에
    게임에서 이런 모델을 vertex 및 index buffer로 load하는 코드가 필요하다.

    Model Format 선택

    3D 모델을 사용하려면 먼저 파일에 모델을 저장하는 방법을 결정하는 것이 필요하다.

    한가지 방법은 모델링 프로그램을 하나 선택해 특화된 파일 포맷 로딩을 지원하는 것이나
    3D 모델링 프로그램의 기능 세트는 게임보다 훨씬 많아 모든 기능 복제는 어렵다.
    (NURBS, quads, n-gons 등 여러 타입의 지오메트리,geometry 와 ray-tracing 등)

    또한 대부분의 모델링 파일은 런타임 때 불필요한 많은 양의 데이터를 가진다.
    (ex: 파일 포맷에 모델의 실행 취소 기록 저장 등)
    게임은 실행 때 이런 데이터가 필요없다.
    이런 추가적인 정보들은 모델링 파일 포맷이 매우 크며, 런타임 시 파일을 로딩할 때
    성능을 떨어뜨린다.

    모델링 파일 포맷은 내용이 불분명한 부분이 있어, 어떤 포맷의 경우
    문서 자체가 존재하지 않을 수도 있다.
    그래서 리버스 엔지니어링을 통해 분석하지 않으면 로드 자체가 불가능할 수도 있따.

    마지막으로 하나의 모델링 포맷을 선택하면 게임은 하나의 특정한 프로그램과 직접적으로 연관된다.
    다른 프로그램을 사용하고 싶어도 다른 포맷으로의 쉬운 변환 프로세스가 존재하지 않는한 포맷 변경이 어려워진다.

    익스체인지 포맷(exchange format)은 여러 모델링 프로글매에서 동작하는 걸 목표로 한다.
    가장 인기 있는 포맷으로는 FBX와 COLLADA가 있고, 이런 포맷은 여러 모델링 프로그램이 지원한다.
    이런 포맷들을 로딩하기 위한 SDK가 존재하지만, 여전히 런타임 시 너무많은 데이터를포함한다.

    Unity나 Unreal 엔진같은 상업용 엔진의 동작방법을 살펴보는 것도 도움이 된다.
    두 엔진은 자신의 편집기에 FBX 같은 파일 포맷의 import를 지원하지만,
    런타임에서는 이 포맷을 사용하지않는다.
    대신 import할 때 내부 엔진 포맷으로 변경하는 변환 프로세스가 있다.
    이 변환 프로세스를 통해 런타임 시에 게임은 내부 포맷으로 모델을 로드한다.

    다른 엔진들은 인기 있는 모델링 프로그램을 위한 익스포트 플러그인을 지원한다.
    이것은 모델링 프로그램의 포맷을 게임 실행 시에 사용할 수 있도록 설계된 커스텀 포맷으로 변환한다.

    이 공부에선느 커스텀 파일 포맷을 사용한다.
    바이너리 파일 포맷이 보다 효율적이지만(대부분의 게임이 바이너리 파일을 사용한다)
    단순성을 위해 모델파일 포맷은 JSON 텍스트 파일 포맷을 사용한다.
    JSON 포맷을 사용하면 수동으로 모델 파일을 쉽게 편집 가능하고,
    적절히 로드됐는지를 검증하는 것을 쉽게 해준다.
    (나중에 이진 포맷 사용방법을 공부한다.)

    cube.gpmesh는 gpmesh 파일 포맷으로 정육면체를 표현했다.
    1. 버전
    2. 모델에 대한 버텍스 포맷을 지정
        OpenGL에서 vertex format으로 위치에 3개의 float값이 필요했고,
        텍스처 좌표에 2개의 float을 사용했었다.
        이 gpmesh 파일 포맷은 vertex 법선을 위한 3개의 float값을 더 추가한다.
        (vertex 법선은 나중에 조명에서 더 자세히 살펴본다.)
    3. 모델을 그리는 데 사용할 shader program을 지정 (나중에 BasicMesh 셰이더 프로그램을 정의한다)
    4. 텍스처 배열은 모델과 관련된 텍스처 리스트를 지정한다.
    5. 모델에 대한 vetex buffer를 지정한다.
        각 행은 하나의 개별 vertex이다. (위치, 텍스처 좌표, 버텍스 법선 3개 float 값)
    6. 모델에 대한 index buffer를 지정한다.
        각 행은 한 개의 삼각형을 뜻한다.

    물론 모델 파일 포맷은 모델링 프로그램에서 해당 포맷으로 모델을 생성하는 방법을
    가지고 있지 않다면 특별히 유용하지는 않다.
    Exporter 디렉토리에 2가지 익스포터가 있다.
    하나는 블렌더 모델링 프로그램을위한 export script로 기본 형식의 메시를 지원한다.
    다른 하나는 Unreal Engine을 위한 exporter plugin이다.
    이 플러그인은 나중의 skeleton animation에서도 사용된다.

    이 exporter 코드는 블렌더와 언리얼에 상대적으로 특화돼 있따.
    각 exporter는 자신을 모델링 프로그램에서 사용하는 방법을 설명한 텍스트 파일도 포함하고 있다.                  

    vertex 속성 갱신

    gpmesh 파일이 vertex 당 3개의 vertex 속성(위치, 법선, 텍스처 좌표)을 사용하므로
    지금부터는 모든 메시가 이 포맷을 사용한다고 가정한다.

    이제 모든 vertex 배열은 새로운 vertex layout을 사용하도록 변경해준다.
    3개의 속성이 총 8 float이므로 각 vertex의 크기가 된다.

    새로운 vertex layout 참조하는 Sprite.vert도 수정해준다.
    스프라이트 셰이더 프로그램에서는 사용하지 않으므로 Game.cpp에 
    생성한 스프라이트 vertex에는 0으로 법선 벡터를 설정한다.

    gpmesh 파일 로딩

    gpmesh 포맷은 JSON이며, JSON 포맷을 parsing하는데 사용되는 라이브러리는 많다.
    이번엔 RapidJSON을 사용한다.

    텍스처와 비슷하게 메시 로딩은 Mesh 클래스로 캡슐화한다.

    Mesh 클래스가메시와 관련된 모든 텍스처에 접근할 수 있어야된다.
*/