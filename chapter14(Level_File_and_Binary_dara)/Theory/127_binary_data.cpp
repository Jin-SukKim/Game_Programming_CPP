/*
    바이너리 데이터

    여태는 JSON 파일 포맷을 사용했다.
    텍스트 기반 파일 포맷을 사용할 떄의 이점은 수없이 많다.
    텍스트 파일은 사람이 보기에편하고 에러를 찾기가 쉽다.
    그리고 필요하다면 수동 편집이 가능하고 git 같은 소스 제어 시스템과 궁합이 매우 좋다.
    왜냐함녀 두리비전 사이에서 파일이 변경된 것을 쉽게확인 가능하기 때문이다.
    또한 asset이 텍스트 파일이라면 에셋 로딩을 디버깅하는 것은 더욱더 쉽다.

    하지만 텍스트 기반 파일 포맷은 런타임 시에 성능뿐만 아니라 디스크나
    메모리 사용 측면에 있어서 비효율적이라는 데 있다.
    JSON이나 XML 같은 포맷은 {}나 ""같은 서식 설정 문자들을 사용하기에
    디스크상에서 많은 공간을 차지한다.
    그리고 런타임 시에 텍스트 기반 파일을 파싱하는 것은 RapidJSON 같은 고성능 라이브러리조차 느리다.

    텍스트 파일과 바이너리 파일 양쪽의 장점을 최대한 살리기 위해 개발기간에는
    텍스트 파일을 사용하고 최적화 빌드에서는 바이너리 파일을 사용할 수 있다면 좋다.

    그래서 먼저 바이너리 파일이 존재하는지 확인하고 존재한다면 바이너리 파일을 JSON 대신 로드한다.
    바이너리 파일이 없다면 바이너리 버전의 파일을 생성해 다음 번에 게임을 실행할 때 텍스트 버전 대신에
    바이너리 버전을 로드하도록 한다.

    이 방법의 한 가지 잠재적인 단점은 텍스트 포맷에서는 발생하지 않지만 바이너리 포맷에서 버그가 발생할 수도 있다.
    이 문제를 피하려면 개발 전반에 걸쳐 두 포맷 모두를 계속 사용하는 것이 중요하다.
    두 포맷 중 하나가 갱신한지 오래되면 해당 포맷이 작동하지 않을 가능성이 높다.

    바이너리 메시 파일 저장

    바이너리 파일 포맷을 사용할 떄 중요한 단계는 파일의 레이아웃을 결정하는 것이다.
    대부분의 바이너리 파일은 파일의 나머지 부분을 읽는 데 필요한 구체적인 크기 정보뿐만 아니라
    파일의 콘텐츠를 정의하는 헤더로 시작한다.

    ex) 메시 파일의 경우 헤더에 버전 정보를 저장하거나 veretx나 index의 수 등 정보를 저장해야 한다

    이번의 헤더는 packed(가능한 한 구조체의 크기를 줄이는 것)돼 있지 않지만
    packed는 헤더에 저장하려는 항목의 레이아웃에 대한 아이디어를 제공한다.

    struct MeshBinHeader
	{
		// 파일 타입 시그니처
		char mSignature[4] = { 'G', 'M', 'S', 'H' };
		// Version
		uint32_t mVersion = BinaryVersion;
		// Vertex layout 타입
		VertexArray::Layout mLayout = VertexArray::PosNormTex;
		// 텍스처, vertex, 인덱스 수에 대한 정보
		uint32_t mNumTextures = 0;
		uint32_t mNumVerts = 0;
		uint32_t mNumIndices = 0;
		// 충돌에 사용되는 박스/반지름
		AABB mBox{ Vector3d::Zero, Vector3d::Zero };
		float mRadius = 0.0f;
		float mSpecPower = 100.0f;
	};

    mSignature 필드는 파일 타입을 지정하는 특별한 4바이트 매직 넘버다.
    대부분의 인기 있는 바이너리 파일 타입은 시그니처를 가진다.
    시그니처를 사용하면 찾는 시그니처 이외의 다른 부분은 알 필요 없이 처음 몇 바이트에서파일 타입을 알아낼수 있따.
    나머지 데이터는 파일로부터 메시 데이터를 재구축하는 데 필요한 정보다.

    * Endianness(엔디언)을 조심해야 한다.
      CPU 플랫폼이 1바이트보다 큰 값을 저장하는 순서인데 만약 바이너리 데이터를 
      기록한 플랫폼의 엔디언이 바이너리 파일을 읽는 엔디언과 다르다면 정상작동하지 않을것이다.
      최근의 대부분의플랫폼에서는 리틀 엔디언 형식을 취한다.
      
    바이너리 메시 파일 로딩

    로딩하는 것은 방향만 반대일 뿐 쓰는 경우와 같다.
    먼저헤더를 로드하고 헤더의 유효성을 확인한다.
    그리고 텍스처를 로드하고 버텍스와 인덱스 데이털르 로드한 후 마지막으로 실제 VertexArray를 생성한다.
    (데이터는 OpenGL을 통해 GPU로 업로드될것이다)

    먼저 이진 모드로 파일을 연다.
    그 후 read 함수로 헤더를 읽는다.
    write 함수와 마찬가지로 read 함수는 기록할 버퍼인 char*를 첫 번째 파라미터로 받고 파일로부터 읽어들일 바이트수를
    두번째 파라미터로 받는다.
    그 후 헤더상의 시그니처와 버전이 일치하는지 검증한다.

    모든 텍스처 파일 일름을 읽어들여 텍스처를 로드하고 버텍스와 인덱스 버퍼를 저장할 메모리를 할당하고,
    파일로부터데이털르 얻기 위해 read 함수를 사용한다.
    vertex/index 데이터를 얻고난 후 이 정보들을 토대로 VertexArray 개체를 생성한다.
    함수가 종료되기 전 메모리를 정리하고 mBox/mRadius 멤버 변숙밧을 설정한다(반지름,박슥밧)

    파일 로드에 실패하면 JSON parsing을 한다.


    바이너리 메시파일 로딩으로 전환하면 성능이 디버그 모드에서 크게 향상된다.
    시간과 공간 모두 향상된다.

    하지만 최적화 빌드에서 JSON과 바이너리 둘의 성능은 거의동일하다.
    RapidJson 라이브러리 릴리스 모드에서 매우 최적화가 잘돼 있거나 또는 GPU에 데이터를 전송하거나
    텍스처를 로딩하는 등의 기본 작업이 대부분의 오버헤드를 차지하고 있기 때문일 수 있다.

    디스크 공간 측면에서 살며보면 공간은 매우 정략된다.
*/