/*
    지연 셰이딩 구현은 몇 가지 단계가 필요하다.

    1. 다중 출력 체스처를 지원하는 프레임 버퍼 개체를 설정한다.
    2. 표면 특성을 G 버퍼에 쓰는 프래그먼트 셰이더를 작성한다.
    3. 전체 화면을 다룰 수 있고 G 버퍼의 샘플을 다룰 수 있는 사각형을 그려
       전역 조명(방향광, 주변광 등)의 결과를 출력할 수 있게한다.
    4. 비전역 광원(점광, 스포트라이트 등)에 대한 조명을 계산한다.

    G 버퍼 클래스 생성

    G 버퍼용 FBO는 거울 FBO보다 복잡하므로 FBO와 FBO와 관련된 모든 텍스처를
    새로운 GBuffer 클래스로 캡슈로하해준다.

    G 버퍼에 저장될 텍스처의 데이터 타입을 정의하는 열거형을 선언한다.
    G 버퍼는 분산 색상, 법선, 그리고 각 표면의 세계 위치를 저장한다.
    (세계 위치 저장 시 계산이 편해지지만 메모리 사용량과 렌더링 대역폭 사용량이 증가한다.
    깊이 버퍼와 뷰-투영 행렬로부터 픽셀상의 세계 위치를 다시 알아내는 것이 가능하다.)

    이 G 버퍼에서 누락된 표면의 특성 중 하나는 반사 지수다.
    즉, 퐁 반사 모델의 반사 요소를 계산할 수 없다.

    Create 함수는 먼저 프레임 버퍼 개체를 생성하고 깊이 버퍼 타깃을 추가한다.
    그 후 G 버퍼에서 쓰이는 각각의 타입에 대한 별도의 텍스처 인스턴스를 만든다.
    (각 텍스처 타입은 별도의 렌더 타깃이기 때문이다)
    각 텍스처는 GL_RGB32F 포맷으로 설정된다.

    이는 텍셀마다 3개의 요소가 있다는 것을 뜻하고, 이 요소 각각은 32비트 단정밀도 부동 소수점 값을 의미한다.
    glFramebufferTexture 호출은 각 텍스처를 해당 색상 슬롯에 연결한다.
    OpenGL은 색상 슬롯을 번호로 정의하므로 코드는 텍스처와 색상 슬롯 연결을 위해
    연속되는 숫자를 사용한다.

    모든 색상 슬롯 번호를 가진 벡터를 생성한 뒤 벡터의 크기와 데이터를 인자로 받는
    glDrawBuffers를 호출해 G 버퍼에 텍스처 슬롯을 설정한다.

    그 후 GBuffer 포인터를 Renderer의 멤버 데이터로 추가한다.
    Initialize에서 GBUffer 객체를 생성하고 화면의 너비/높이로 설정한다.

    G 버퍼에 쓰기

    G 버퍼가 준비됐으니 데이터를 G 버퍼에 써준다.
    현재의 메시 렌더링은 완전히 조명 처리된 최종 색상을 기본 프레임 버퍼에
    쓸 때 퐁 프래그먼트 셰이더를 사용중디ㅏ.
    하지만 이 퐁 프래그먼트 셰이더는 지연 셰이딩의 접근 방식과는 반대라 새로운 frag shader를 생성하준다.

    이전 셰이더와 생성할 셰이더의 차이점은 모든 이전 frag shader는 하나의 출력값만을 썻지만
    새로운 셰이더는 여러 출력값 또는 복수의 렌더 타깃을 가진다.
    즉, G 버퍼의 각 텍스처, 즉 올바른 출력에 데이터를 쓸 수 있어야 한다.

    frag shader는 텍스처로부터 분산광을 샘플링하며 법선과 세계 위치를 G 버퍼로 직접 전달한다.

    GBufferWrite.frag는 3개의 G 버퍼용 텍스처를 위한 3개의 out 값을 선언한다.
    또한 각 출력에 대한 레이아웃 번호도 지정한다.
    이 번호는 G 버퍼에 생성했을 떄 지정한 색상 슬롯 인덱스에 해당한다.

    그 후 mMeshShader와 mSkinnedShader가 이전의 Phong.frag 대신 새로운 GBufferWrtie.frag를 사용하도록 한다.

    Renderer::Draw에서는 기본 프레임 버퍼에 그리는 Draw3DScrene 호출을 수정해
    기본 프레임 버퍼 대신 G 버퍼로 그리기를 수행한다.

    현재 상태에서 게임 실행시 UI 요소를 제외하고 전체적으로 검은 창이 출력된다.
    표면 특성을 G 버퍼에 쓰지만 기본 프레임 버퍼에 아무것도 그리지 않기 때문이다.
    그러나 RenderDoc(그래픽 디버거) 같은 그래픽 디버거를 사용하면 G 버퍼의 여러 텍스처에
    대한 출력을 보는것이 가능하다.

    점점 복잡해지는 그래픽 코드는 디버깅하기가 매우 힘들다.
    그래서 나온게 그래픽 디버거인데 OpenGL을 지원하는 최고의 그래픽 디버거는 RenerDoc으로 오픈소스툴이다.
*/