/*
    점광(point light) 추가

    지연 셰이딩을 사용하는 주된 이유는 장면에서 광원의 수가 증가해도
    잘 대처하기 위해서이다.
    이번엔 여러 비전역 광원에 대한 지원을 추가하는 방법을 설명한다.

    게임에 1000개의 점광이 있다고 가정하면, 개발자는 셰이더에서 
    위치, 색상, 반지름 등 점광의 몯느 정보를 저장하는 uniform 배열을 생성하야 한다.
    그리고 GBufferGlobal.frag 셰이더코드에서는 이 점광들ㅇ르 반복한다.
    G 버퍼로부터 샘플링한 세계 위치를 사용하면 fragment가 점광의 범위 내에 있는지
    여부를 판별할 수 있으며, 범위 내에 있다면 이 프래그먼트에 대한 퐁 방정식을 계산한다.

    이 방법은 문제점은 점광 근처에 있지 않은 fragment도 테스트를 수행해야 한다는것이다.
    이를 방지하려면 셰이더 코드에서 수많은 조건 검사를 수행해야 하며 비용이 매우 크다.

    이 문제의 해결책은 광원 기하(light geometry)나 광원을 나타내는 메시를 대신 사용하는 것이다.
    점 광원은 반지름을 가지므로 점광에 해당하는 광원 기하는 세계상에 배치된 구체와 같다.
    이 구체의 영향 범위에 있는 모든 프래그먼트는 frag shader 호출을 실행시킨다.
    또한 G 버퍼의 세계 위치 정보를 사용해 fragment에 대한 빛의 세기 계산도 가능하다.
   
    점광에 대한 컴포넌트를 생성하면 광원을 이동하는 액터에 붙이는 것이 쉬워진다.

    PointLightComponent 클래스 추가

    문제를 간단히 하기위해 멤버 변수를 public으로 선언한다.
    분산 색상은 점광의 분산 색상이다.
    내부 및 외부 반지름 변수는 점광의 주변 영향 영역을 결정한다.

    외부 반지름(outer radius)은 점광이 물체에 영향을 끼치는 최대 거리다.
    내부 반지름(inner radius)은 점광이 빛의 최대 세기를 가질 때의 반지름이다.

    내부 반지름 범위 안에 있는 물체는 완전한 분산 색상을 가지며,
    색상의 세기는 외부 반지름에 가까워질수록 감쇄한다.

    점광은 외부 반지름을 넘어서면 아무런 영향을 미치지 않는다.

    그리고 렌더러 클래스에 mPointLights라는 포인터의 벡터를 추가한다.
    이 클래스의 생성자는 mPointLights에 광원을 추가하고 소멸자는 벡터로부터 광원을 제거한다.
    
    점광 프래그먼트 셰이더

    이제 GBufferPointLight.frag를 생성한다.
    GBufferGlobal.frag와 같이 G 버퍼용 3개 텍스처에 대한 3개의 sampler2D uniform 선언을 한다.
    추가로 전역 조명 세이더와 다르게 특정 점광에 대한 정보를 저장하는 것이 필요하다.
    
    PointLight 구조체를 선언한 뒤 uPointLight uniform을 추가한다.
    그리고 화면의 너비/높이를 저장한 uScreenDimensions uniform도 추가한다.

    메인 함수는 전역 조명 셰이더와 많이 다르다.
    전역 조명을 위해 그린 사각형의 텍스처 좌표를 사용하면 올바르게 G 버퍼에서
    데이터 샘플링하는 것이 가능했다.

    그러나 점광의 구면 메시에서 얻은 텍스처 좌표로는 샘플링할 G 버퍼의 올바른 UV 좌표를 얻어낼 수 없다.
    그래서 프래그먼트의 화면 공간 위치 정보가 있는 내장 GLSL 변수인 gl_FragCoord를 사용한다.
    여기서는 x와 y 좌표만 신경쓰면 된다.
    UV 좌표는 [0, 1] 범위에 있으므로 좌표를 화면 크기로 나눠주면 된다.

    올바른 uv 좌푤르 얻은 후에는 이 uv 좌표를 사용해서 분산 색상, 법선 그리고 세계 위치를 
    G 버퍼로부터 샘플링한다.
    그리고 퐁 셰이더 처럼 N 및 L 벡터를 계산한다.

    분산 색상 계산할 땐 먼저 점광의 중심과 프래그먼트의 세계 위치의 차를 계산한다.
    smoothstep 함수는 [0, 1]의값을 반환하며 내부 반지름과같거나 작으면
    0을 return하고 외부 반지름보다 같거나 크면 1을 반환한다.

    내부 반지름과 외부  반지름 사이에 있는 거리는 중간값을 산출한다.
    smoothstep 함수는 이 중간값 계산ㅇ르위해 Hermite 함수(다항식의 한 형태)를 사용한다.
    결괏값은 분산 색상의 세기에 해당한다.
    0의 값은 프래그먼트가 내부 반지름 내에있기에 최대 세기를 뜻하며 1은 프래그먼트에 영향을 받지 않음을 뜻한다.

    다음으로 빛의 세기 값을 토대로 DIffuseColor를 계산한다.
    여기서 mix 함수는 점광의 분산 색상과 순수 검은색과의 선형 보간을 수행한다.
    현재는 G 버퍼에 반사 지수가 없기에 반사 요소 계산은 하지 않는다.

    전역 광원 G 버퍼 계산 후에 점광 렌더링이 수행되므로 프레임 버퍼상의 각 프래그먼트는
    이미 색상을 갖고있다.
    그래서 점광 셰이더는 프레임 버퍼에 있는 기존 색상ㅇ츨 덮어써서는 안된다.

    ex) 프래그먼트의 세계 위치가 점광의 범위 밖에 있다면 셰이더는 검정색을 반환
        만약 그냥 프래그먼트를 검정색으로 설정하면 전역 조명 패스에서 구한 모든 색상을 잃어버린다.

    색을 덮어쓰기보다는 이미 있던 색상에 점광 셰이더의 출력을 더해야 한다.
    색상에 검정색을 더하면 RGB 값은 변경되지 않으며, 이는 기존 광원을 그대로 유지한다.
    한편 녹색값을 더하면 프개르먼트는 녹색 느낌이 강해진다.
    출력 색상을 기존 색상에 더하기 위해 프래그먼트 셰이더 코드 변경은 불필요하다.

*/