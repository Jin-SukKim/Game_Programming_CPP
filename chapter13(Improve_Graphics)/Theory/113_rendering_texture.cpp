/*
    텍스처로 렌더링

    여태까진 폴리곤을 색상 버퍼에 직접 그렸다.
    색상 버퍼는 개발자가 특정 좌표로 색상을 쓸 수 있는 2D 이미지이다.
    그래서 임의의 텍스처로 장면을 그리는 것 또한 가능하다.

    텍스처로 렌더링하는 것이 불필요하다고 여겨질 수 있지만 텍스처로 렌더링하는 여러 이유가 있따.
    ex) 레이싱 게임에 백미러를 가진 차가 있을때, 거울이 정확하게 보이려면 게임 세계를
        백미러의 관점에서 텍스처로 렌더링한 다음, 장면의 백미러에 텍스처를 그리면 된다.

    일부 그래픽 기술은 색상 버퍼로 최종 출력을 계산하기 전에 임시 저장장소로써 텍스처를 사용한다.
    그래서 텍스처로 렌더링하는 방법을 살펴보고 화면상에 이 텍스처를 그리는 방법은 살펴본다.

    이 작업을 위해 이전 색상 버퍼로 직접 모든 걸 그렸던 렌더링 코드 전반에 걸쳐 수정ㅇ ㅣ필요하다.
    또한 여러 카메라의 관점에서 장면을 렌더링하기 위한 지원을 추가한다.

    * tip
    대형 거울 같은 고품질 반사의 경우 거울 표면 관점에서 장면을 렌더링해준다.
    하지만 게임 장면이 저품질 반사가 필요한 수많은 표면을 포함하면 표면 각각의 관점에서의
    장면 렌더링은 비용이 너무 크다.
    그래서 전체 장면에 대한 단일 반사 맵(reflection map)을 생성하면 좋다.
    그 후 반사 이미지에 대한 모든 젚무질 반사 표면 샘플을 이 반사맵으로부터 효율적으로 얻어온다.

    텍스처 생성하기(CreateForRendering 함수)

    첫째로 텍스처 렌더링을 위해 일단 텍스처를 생성해줘야한다.
    Texture 클래스에 텍스처 생성 지원을 위한 함수를 추가한다.

    이전 텍스처 생성 코드와 비슷하나 RGBA 포맷(요소당 8비트이며 픽셀당 32비트)을 지정하지 않고,
    파라미터를 사용해 포맷을 지정한다.
    
    둘쨰로 텍스처는 초기 데이터가 없으므로 glTexImage2D의 마지막 파라미터는 nullptr이다.
    이 마지막 파라미터가 nullptr이면 두 번째, 세 번째 파라미터는 무시된다.
    
    마지막으로로 텍스처에 밉매핑이나 이중 선형 필터링을 의도적으로 활성화시키지 않도록 한다.
    텍스처로부터 정확히 실제 출력과 일치하는 샘플링 데이터가 필요해서이다.
*/