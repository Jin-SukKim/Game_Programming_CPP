/*
    오브젝트 회전시키기

    오브젝트가 x축을 향하고 위치 S에 있을 때 임의의 점 P를 향하도록 회전
    
    1. 먼저 새로운 지점으로의 벡터를 계산한 뒤 이 벡터를 정규화한다.

    NewFacing = (P-S) / (||P-S||), 향하고자 하는 방향

    2. 그리고 초기에 향한 방향과 대상 물체를 향항 방향의 외적을 통해 회전축을 계산 후 정규화

    // x축을 향하고 있으므로 3D vector는 (1, 0, 0)이 된다.
    a = ((1, 0, 0) x NewFacing) / (||(1, 0, 0) x NewFacing||), 회전축 정규화

    외적의 결과가 0인 경우 두 벡터가 평행하다는 의미이므로 회전을 적용할 필요가 없다.
    그리고 분모는 0이 될수 없다.
    벡터가 평행한 경우 방향만 확인해줘 서로 반대 방향을 향하면 상향 벡터 기준으로 PI radian(180도) 회전시켜준다.

    3. 다음으로 내적과 arccos을 사용해 회전 각도를 계산한다.

    각도 = arccos((1,0,0)*NewFacing)

    4. 마지막으로 구한 회전축과 각도를 결합해 점 P로 향하는 우주선의 회전을 나타내는 쿼터니언을 생성한다.

    q = [qv, qs]
    qv = a * sin(각도 / 2), a = 정규화한 회전축 벡터
    qs = cos(각도 / 2)

    P가 3D 공간상의 어떤 위치에 있다 하더라도 이 프로세스는 잘 동작한다.

    회전 결합

    쿼터니언의 또 다른 일반 연산 중 하나틑 기존 쿼터니언에 추가 회전을 적용하는 것이다.
    두 쿼터니언 p, q가 주어졌을 때 그라스만 곱(Grassmann product)은 대상을 q로 회전한 뒤 p로 회전시킨다.

    그라스만 곱(Grassmann product)
    x = 외적, * = 내적, v = 벡터, s = 스칼라
    (pq)v = psqv + qspv + pv x qv,  // ps * qv + qs * pv + pv x qv
    (pq)s = psqs - pv * qv          // ps * qs - pv . qv

    곱셈에서 q의 왼쪽에 p가 있더라도 회전은 오른쪽에서 왼쪽 순서로 적용된다.
    또한 그라스만 곱은 외적을 사용하므로 교환할 수 없다.
    p와 q의 순서를 바꾸면 회전 순서도 바뀐다.

    행렬과 유사하게 쿼터니언은 역 쿼터니언을 가진다.
    단위 쿼터니언에서 쿼터니언의 역은 벡터 요소를 반전시킨면 된다.

    q^-1 = [-qv, qs]

    역 쿼터니언이 있으므로 다음과 같이 정의된 항등 쿼터니언도 있다.

    iv = (0, 0, 0)
    is = 1

    벡터를 쿼터니언으로 회전시키기

    3D 벡터 v를 쿼터니언 q로 회전시키기 위해 v를 쿼터니언 r로 나타낸다

    r = [v, 0]

    그리고 두 쿼터니언의 그라스만 곱인 r'을 계산한다

    r' = (qr)q^-1

    그러면 회전된 벡터는 쿼터니언 r'의 벡터 요소와 같다.

    v' = rv'
    
    벡터를 쿼터니언으로 변화(Transform)시키는 방정식

    v' = v + 2 x qv x (qv x v + qs * v)

    구면 선형 보간 쿼터니언은 구면 선형 보간(Slerp, Spherical Linear Interpolation)이란
    보다 정확한 보간 형태를 지원한다.
    Slerp 방정식은 두 쿼터니언 a, b와 a에서 b까지의 [0, 1] 범위 분수값을 인자로 받는다.
    구면 선형 보간을 사용하는 이유는 쿼터니언은 보통 구의 형태를 띄는데
    그냥 선형 보간을 사용하면 일직선으로 움직이므로 오차가 생긴다.
    즉 구의 호를 따라 보간을 해 좀 더 정확한 보간을 해주는 것이다.

    쿼터니언의 선형 보간 방정식 

    r = (1-t)*P1 + t*P2

    두 점 사이의 구면 선형 보간의 방정식
    0 <= t <= 1인 단위원

    r = sin(각도 * (1-t)) / sin각도 * P1 + sin(각도 * t) / sin각도 * P2
    각도(P1과 P2 사이의 각) = acos(P1 * P2) // 내적

    ex) a에서 b 경로로 25% 회전한 쿼터니언 생성

    Slerp(a, b, 0.25)

    쿼터니언을 회전 행렬로

    게임은 세계 변환 행렬을 사용하므로 쿼터니언을 코드에서 사용하려면 회전 행렬로 변환해야 한다.
    쿼터니언을 행렬로 변환하는 것은 매우 복잡하다.

    qv = (qx, qy, qz)
    qs = qw
                | 1-2qy^2-2qz^2   2qxqy+2qwqz   2qxqz-2qwqy   0 |
    Rotate(q) = | 2qxqy-2qwqz    1-2qx^2-2qz^2  2qyqz+2qwqx   0 |
                | 2qxqz+2qwqy    2qyqz-2qwqx   1-2qx^2-wqy^2  0 |
                |      0               0             0        1 |

    코드상의 쿼터니언(Quaternion 클래스)

    쿼터니언의 곱셈 순서는 종종 혼선을 주므로(ex: p로 회전한 후 q로 회전하려면 qp로 곱해야한다)
    혼선을 주지 않도록 MathUtils의 곱셈 연산자를 사용하는 대신 Concatenate 함수를 선언했다.

    Concatenate 함수는 기대하는 순서로 쿼터니언 인자를 받아 곱셈순서를 조정해준다.

    지금 시스템은 왼손 좌표계를 사용하므로 +x는 앞을 의미한다.
    그럼 초기 전방 벡터(+x, (1, 0, 0))를 회전 쿼터니언으로 회전시켜 전방 벡터를 얻는다.

    현재 프로젝트는 문제를 간단히 하기 위해 +z 축(요)에[ 대해서만 회전을 한다.
    

*/